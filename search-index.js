var N=null,E="",T="t",U="u",searchIndex={};
var R=["sparse","isextended","offset","Representation of the header of an entry in an archive","linkname","typeflag","version","dev_major","dev_minor","Directory","entries","into_inner","Unwrap this archive, returning the underlying object.","result","option","set_unpack_xattrs","Indicate whether extended file attributes (xattrs on Unix)…","set_preserve_permissions","Indicate whether extended permissions (like suid on Unix)…","set_preserve_mtime","Indicate whether access time information is preserved when…","entrytype","Returns whether this type represents a GNU long name header.","Returns whether this type represents a GNU long link header.","header","oldheader","ustarheader","gnuheader","Returns a view into this header as a byte array.","metadata","headermode","path_bytes","link_name","link_name_bytes","utf8error","Views this as a normal `Header`","set_path","username_bytes","set_username","groupname_bytes","set_groupname","device_major","set_device_major","device_minor","set_device_minor","as_header","as_header_mut","See `Header::username_bytes`","See `Header::set_username`","See `Header::groupname_bytes`","See `Header::set_groupname`","See `Header::device_major`","See `Header::set_device_major`","See `Header::device_minor`","See `Header::set_device_minor`","Returns the last modification time in Unix time format","as_bytes","as_mut_bytes","is_extended","try_from","try_into","borrow_mut","type_id","borrow","typeid","into_iter","to_owned","clone_into","formatter","GnuExtSparseHeader","GnuHeader","GnuSparseHeader","OldHeader","UstarHeader","EntryType","HeaderMode","PaxExtension","PaxExtensions"];

searchIndex["tar"]={"doc":"A library for reading and writing TAR archives","i":[[3,"Archive","tar","A top-level representation of an archive file.",N,N],[3,"Entries",E,"An iterator over the entries of an archive.",N,N],[3,"Builder",E,"A structure for building archives",N,N],[3,"Entry",E,"A read-only view into an entry of an archive.",N,N],[3,R[69],E,"Representation of the entry found to represent extended…",N,N],[12,R[0],E,E,0,N],[12,R[1],E,E,0,N],[12,"padding",E,E,0,N],[3,R[70],E,R[3],N,N],[12,"name",E,E,1,N],[12,"mode",E,E,1,N],[12,"uid",E,E,1,N],[12,"gid",E,E,1,N],[12,"size",E,E,1,N],[12,"mtime",E,E,1,N],[12,"cksum",E,E,1,N],[12,R[5],E,E,1,N],[12,R[4],E,E,1,N],[12,"magic",E,E,1,N],[12,R[6],E,E,1,N],[12,"uname",E,E,1,N],[12,"gname",E,E,1,N],[12,R[7],E,E,1,N],[12,R[8],E,E,1,N],[12,"atime",E,E,1,N],[12,"ctime",E,E,1,N],[12,R[2],E,E,1,N],[12,"longnames",E,E,1,N],[12,"unused",E,E,1,N],[12,R[0],E,E,1,N],[12,R[1],E,E,1,N],[12,"realsize",E,E,1,N],[12,"pad",E,E,1,N],[3,R[71],E,"Description of the header of a spare entry.",N,N],[12,R[2],E,E,2,N],[12,"numbytes",E,E,2,N],[3,"Header",E,R[3],N,N],[3,R[72],E,R[3],N,N],[12,"name",E,E,3,N],[12,"mode",E,E,3,N],[12,"uid",E,E,3,N],[12,"gid",E,E,3,N],[12,"size",E,E,3,N],[12,"mtime",E,E,3,N],[12,"cksum",E,E,3,N],[12,"linkflag",E,E,3,N],[12,R[4],E,E,3,N],[12,"pad",E,E,3,N],[3,R[73],E,R[3],N,N],[12,"name",E,E,4,N],[12,"mode",E,E,4,N],[12,"uid",E,E,4,N],[12,"gid",E,E,4,N],[12,"size",E,E,4,N],[12,"mtime",E,E,4,N],[12,"cksum",E,E,4,N],[12,R[5],E,E,4,N],[12,R[4],E,E,4,N],[12,"magic",E,E,4,N],[12,R[6],E,E,4,N],[12,"uname",E,E,4,N],[12,"gname",E,E,4,N],[12,R[7],E,E,4,N],[12,R[8],E,E,4,N],[12,"prefix",E,E,4,N],[12,"pad",E,E,4,N],[3,R[76],E,"A key/value pair corresponding to a pax extension.",N,N],[3,R[77],E,"An iterator over the pax extensions in an archive entry.",N,N],[4,R[74],E,"Indicate for the type of file described by a header.",N,N],[13,"Regular",E,"Regular file",5,N],[13,"Link",E,"Hard link",5,N],[13,"Symlink",E,"Symbolic link",5,N],[13,"Char",E,"Character device",5,N],[13,"Block",E,"Block device",5,N],[13,R[9],E,R[9],5,N],[13,"Fifo",E,"Named pipe (fifo)",5,N],[13,"Continuous",E,"Implementation-defined 'high-performance' type, treated as…",5,N],[13,"GNULongName",E,"GNU extension - long file name",5,N],[13,"GNULongLink",E,"GNU extension - long link name (link target)",5,N],[13,"GNUSparse",E,"GNU extension - sparse file",5,N],[13,"XGlobalHeader",E,"Global extended header",5,N],[13,"XHeader",E,"Extended Header",5,N],[4,R[75],E,"Declares the information that should be included when…",N,N],[13,"Complete",E,"All supported metadata, including mod/access times and…",6,N],[13,"Deterministic",E,"Only metadata that is directly relevant to the identity of…",6,N],[11,"new",E,"Create a new archive with the underlying object as the…",7,[[["r"]],["archive"]]],[11,R[11],E,R[12],7,[[],["r"]]],[11,R[10],E,"Construct an iterator over the entries in this archive.",7,[[["self"]],[[R[13],[R[10]]],[R[10]]]]],[11,"unpack",E,"Unpacks the contents tarball into the specified `dst`.",7,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,R[15],E,R[16],7,[[["self"],["bool"]]]],[11,R[17],E,R[18],7,[[["self"],["bool"]]]],[11,R[19],E,R[20],7,[[["self"],["bool"]]]],[11,"set_ignore_zeros",E,"Ignore zeroed headers, which would otherwise indicate to…",7,[[["self"],["bool"]]]],[11,"raw",E,"Indicates whether this iterator will return raw entries or…",8,[[["bool"]],[R[10]]]],[11,"new",E,"Create a new archive builder with the underlying object as…",9,[[["w"]],["builder"]]],[11,"mode",E,"Changes the HeaderMode that will be used when reading fs…",9,[[["self"],[R[30]]]]],[11,"follow_symlinks",E,"Follow symlinks, archiving the contents of the file they…",9,[[["self"],["bool"]]]],[11,"get_ref",E,"Gets shared reference to the underlying object.",9,[[["self"]],["w"]]],[11,"get_mut",E,"Gets mutable reference to the underlying object.",9,[[["self"]],["w"]]],[11,R[11],E,R[12],9,[[],[R[13]]]],[11,"append",E,"Adds a new entry to this archive.",9,[[["self"],[R[24]],["read"]],[R[13]]]],[11,"append_data",E,"Adds a new entry to this archive with the specified path.",9,[[["self"],["asref",["path"]],[R[24]],["path"],["read"]],[R[13]]]],[11,"append_path",E,"Adds a file on the local filesystem to this archive.",9,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,"append_path_with_name",E,"Adds a file on the local filesystem to this archive under…",9,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,"append_file",E,"Adds a file to this archive with the given path as the…",9,[[["self"],["asref",["path"]],["path"],["file"]],[R[13]]]],[11,"append_dir",E,"Adds a directory to this archive with the given path as…",9,[[["self"],["q"],["p"]],[R[13]]]],[11,"append_dir_all",E,"Adds a directory and all of its contents (recursively) to…",9,[[["self"],["q"],["p"]],[R[13]]]],[11,"finish",E,"Finish writing this archive, emitting the termination…",9,[[["self"]],[R[13]]]],[11,"path",E,"Returns the path name for this entry.",10,[[["self"]],[["cow",["path"]],[R[13],["cow"]]]]],[11,R[31],E,"Returns the raw bytes listed for this entry.",10,[[["self"]],["cow"]]],[11,R[32],E,"Returns the link name for this entry, if any is found.",10,[[["self"]],[[R[14],["cow"]],[R[13],[R[14]]]]]],[11,R[33],E,"Returns the link name for this entry, in bytes, if listed.",10,[[["self"]],[[R[14],["cow"]],["cow"]]]],[11,"pax_extensions",E,"Returns an iterator over the pax extensions contained in…",10,[[["self"]],[[R[13],[R[14]]],[R[14],["paxextensions"]]]]],[11,R[24],E,"Returns access to the header of this entry in the archive.",10,[[["self"]],[R[24]]]],[11,"raw_header_position",E,"Returns the starting position, in bytes, of the header of…",10,[[["self"]],["u64"]]],[11,"raw_file_position",E,"Returns the starting position, in bytes, of the file of…",10,[[["self"]],["u64"]]],[11,"unpack",E,"Writes this file to the specified location.",10,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,"unpack_in",E,"Extracts this file under the specified path, avoiding…",10,[[["self"],["asref",["path"]],["path"]],[["bool"],[R[13],["bool"]]]]],[11,R[15],E,R[16],10,[[["self"],["bool"]]]],[11,R[17],E,R[18],10,[[["self"],["bool"]]]],[11,R[19],E,R[20],10,[[["self"],["bool"]]]],[11,"new",E,"Creates a new entry type from a raw byte.",5,[[["u8"]],[R[21]]]],[11,"as_byte",E,"Returns the raw underlying byte that this entry type…",5,[[["self"]],["u8"]]],[11,"file",E,"Creates a new entry type representing a regular file.",5,[[],[R[21]]]],[11,"hard_link",E,"Creates a new entry type representing a hard link.",5,[[],[R[21]]]],[11,"symlink",E,"Creates a new entry type representing a symlink.",5,[[],[R[21]]]],[11,"character_special",E,"Creates a new entry type representing a character special…",5,[[],[R[21]]]],[11,"block_special",E,"Creates a new entry type representing a block special…",5,[[],[R[21]]]],[11,"dir",E,"Creates a new entry type representing a directory.",5,[[],[R[21]]]],[11,"fifo",E,"Creates a new entry type representing a FIFO.",5,[[],[R[21]]]],[11,"contiguous",E,"Creates a new entry type representing a contiguous file.",5,[[],[R[21]]]],[11,"is_file",E,"Returns whether this type represents a regular file.",5,[[["self"]],["bool"]]],[11,"is_hard_link",E,"Returns whether this type represents a hard link.",5,[[["self"]],["bool"]]],[11,"is_symlink",E,"Returns whether this type represents a symlink.",5,[[["self"]],["bool"]]],[11,"is_character_special",E,"Returns whether this type represents a character special…",5,[[["self"]],["bool"]]],[11,"is_block_special",E,"Returns whether this type represents a block special device.",5,[[["self"]],["bool"]]],[11,"is_dir",E,"Returns whether this type represents a directory.",5,[[["self"]],["bool"]]],[11,"is_fifo",E,"Returns whether this type represents a FIFO.",5,[[["self"]],["bool"]]],[11,"is_contiguous",E,"Returns whether this type represents a contiguous file.",5,[[["self"]],["bool"]]],[11,"is_gnu_longname",E,R[22],5,[[["self"]],["bool"]]],[11,"is_gnu_sparse",E,"Returns whether this type represents a GNU sparse header.",5,[[["self"]],["bool"]]],[11,"is_gnu_longlink",E,R[23],5,[[["self"]],["bool"]]],[11,"is_pax_global_extensions",E,R[22],5,[[["self"]],["bool"]]],[11,"is_pax_local_extensions",E,R[23],5,[[["self"]],["bool"]]],[11,"new_gnu",E,"Creates a new blank GNU header.",11,[[],[R[24]]]],[11,"new_ustar",E,"Creates a new blank UStar header.",11,[[],[R[24]]]],[11,"new_old",E,"Creates a new blank old header.",11,[[],[R[24]]]],[11,"as_old",E,"View this archive header as a raw \"old\" archive header.",11,[[["self"]],[R[25]]]],[11,"as_old_mut",E,"Same as `as_old`, but the mutable version.",11,[[["self"]],[R[25]]]],[11,"as_ustar",E,"View this archive header as a raw UStar archive header.",11,[[["self"]],[[R[14],[R[26]]],[R[26]]]]],[11,"as_ustar_mut",E,"Same as `as_ustar_mut`, but the mutable version.",11,[[["self"]],[[R[26]],[R[14],[R[26]]]]]],[11,"as_gnu",E,"View this archive header as a raw GNU archive header.",11,[[["self"]],[[R[14],[R[27]]],[R[27]]]]],[11,"as_gnu_mut",E,"Same as `as_gnu`, but the mutable version.",11,[[["self"]],[[R[14],[R[27]]],[R[27]]]]],[11,"from_byte_slice",E,"Treats the given byte slice as a header.",11,[[],[R[24]]]],[11,R[56],E,R[28],11,[[["self"]]]],[11,R[57],E,R[28],11,[[["self"]]]],[11,"set_metadata",E,"Blanket sets the metadata in this header from the metadata…",11,[[["self"],[R[29]]]]],[11,"set_metadata_in_mode",E,"Sets only the metadata relevant to the given HeaderMode in…",11,[[["self"],[R[29]],[R[30]]]]],[11,"entry_size",E,"Returns the size of entry's data this header represents.",11,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"size",E,"Returns the file size this header represents.",11,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_size",E,"Encodes the `size` argument into the size field of this…",11,[[["self"],["u64"]]]],[11,"path",E,"Returns the raw path name stored in this header.",11,[[["self"]],[["cow",["path"]],[R[13],["cow"]]]]],[11,R[31],E,"Returns the pathname stored in this header as a byte array.",11,[[["self"]],["cow"]]],[11,R[36],E,"Sets the path name for this header.",11,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,R[32],E,"Returns the link name stored in this header, if any is…",11,[[["self"]],[[R[14],["cow"]],[R[13],[R[14]]]]]],[11,R[33],E,"Returns the link name stored in this header as a byte…",11,[[["self"]],[[R[14],["cow"]],["cow"]]]],[11,"set_link_name",E,"Sets the link name for this header.",11,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,"mode",E,"Returns the mode bits for this file",11,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,"set_mode",E,"Encodes the `mode` provided into this header.",11,[[["self"],["u32"]]]],[11,"uid",E,"Returns the value of the owner's user ID field",11,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_uid",E,"Encodes the `uid` provided into this header.",11,[[["self"],["u64"]]]],[11,"gid",E,"Returns the value of the group's user ID field",11,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_gid",E,"Encodes the `gid` provided into this header.",11,[[["self"],["u64"]]]],[11,"mtime",E,R[55],11,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_mtime",E,"Encodes the `mtime` provided into this header.",11,[[["self"],["u64"]]]],[11,"username",E,"Return the user name of the owner of this file.",11,[[["self"]],[[R[14],["str"]],[R[34]],[R[13],[R[14],R[34]]]]]],[11,R[37],E,"Returns the user name of the owner of this file, if present.",11,[[["self"]],[R[14]]]],[11,R[38],E,"Sets the username inside this header.",11,[[["self"],["str"]],[R[13]]]],[11,"groupname",E,"Return the group name of the owner of this file.",11,[[["self"]],[[R[14],["str"]],[R[34]],[R[13],[R[14],R[34]]]]]],[11,R[39],E,"Returns the group name of the owner of this file, if…",11,[[["self"]],[R[14]]]],[11,R[40],E,"Sets the group name inside this header.",11,[[["self"],["str"]],[R[13]]]],[11,R[41],E,"Returns the device major number, if present.",11,[[["self"]],[[R[13],[R[14]]],[R[14],["u32"]]]]],[11,R[42],E,"Encodes the value `major` into the dev_major field of this…",11,[[["self"],["u32"]],[R[13]]]],[11,R[43],E,"Returns the device minor number, if present.",11,[[["self"]],[[R[13],[R[14]]],[R[14],["u32"]]]]],[11,R[44],E,"Encodes the value `minor` into the dev_minor field of this…",11,[[["self"],["u32"]],[R[13]]]],[11,"entry_type",E,"Returns the type of file described by this header.",11,[[["self"]],[R[21]]]],[11,"set_entry_type",E,"Sets the type of file that will be described by this header.",11,[[["self"],[R[21]]]]],[11,"cksum",E,"Returns the checksum field of this header.",11,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,"set_cksum",E,"Sets the checksum field of this header based on the…",11,[[["self"]]]],[11,R[45],E,R[35],3,[[["self"]],[R[24]]]],[11,R[46],E,R[35],3,[[["self"]],[R[24]]]],[11,R[31],E,"See `Header::path_bytes`",4,[[["self"]],["cow"]]],[11,R[36],E,"See `Header::set_path`",4,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,R[37],E,R[47],4,[[["self"]]]],[11,R[38],E,R[48],4,[[["self"],["str"]],[R[13]]]],[11,R[39],E,R[49],4,[[["self"]]]],[11,R[40],E,R[50],4,[[["self"],["str"]],[R[13]]]],[11,R[41],E,R[51],4,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,R[42],E,R[52],4,[[["self"],["u32"]]]],[11,R[43],E,R[53],4,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,R[44],E,R[54],4,[[["self"],["u32"]]]],[11,R[45],E,R[35],4,[[["self"]],[R[24]]]],[11,R[46],E,R[35],4,[[["self"]],[R[24]]]],[11,R[37],E,R[47],1,[[["self"]]]],[11,R[38],E,R[48],1,[[["self"],["str"]],[R[13]]]],[11,R[39],E,R[49],1,[[["self"]]]],[11,R[40],E,R[50],1,[[["self"],["str"]],[R[13]]]],[11,R[41],E,R[51],1,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,R[42],E,R[52],1,[[["self"],["u32"]]]],[11,R[43],E,R[53],1,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,R[44],E,R[54],1,[[["self"],["u32"]]]],[11,"atime",E,R[55],1,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_atime",E,"Encodes the `atime` provided into this header.",1,[[["self"],["u64"]]]],[11,"ctime",E,R[55],1,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_ctime",E,"Encodes the `ctime` provided into this header.",1,[[["self"],["u64"]]]],[11,"real_size",E,"Returns the \"real size\" of the file this header represents.",1,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,R[58],E,"Indicates whether this header will be followed by…",1,[[["self"]],["bool"]]],[11,R[45],E,R[35],1,[[["self"]],[R[24]]]],[11,R[46],E,R[35],1,[[["self"]],[R[24]]]],[11,"is_empty",E,"Returns true if block is empty",2,[[["self"]],["bool"]]],[11,R[2],E,"Offset of the block from the start of the file",2,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"length",E,"Length of the block",2,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"new",E,"Crates a new zero'd out sparse header entry.",0,[[],["gnuextsparseheader"]]],[11,R[56],E,R[28],0,[[["self"]]]],[11,R[57],E,R[28],0,[[["self"]]]],[11,R[0],E,"Returns a slice of the underlying sparse headers.",0,[[["self"]]]],[11,R[58],E,"Indicates if another sparse header should be following…",0,[[["self"]],["bool"]]],[11,"key",E,"Returns the key for this key/value pair parsed as a string.",12,[[["self"]],[["str"],[R[13],["str",R[34]]],[R[34]]]]],[11,"key_bytes",E,"Returns the underlying raw bytes for the key of this…",12,[[["self"]]]],[11,"value",E,"Returns the value for this key/value pair parsed as a…",12,[[["self"]],[["str"],[R[13],["str",R[34]]],[R[34]]]]],[11,"value_bytes",E,"Returns the underlying raw bytes for this value of this…",12,[[["self"]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,"into",E,E,7,[[],[U]]],[11,R[59],E,E,7,[[[U]],[R[13]]]],[11,R[60],E,E,7,[[],[R[13]]]],[11,R[63],E,E,7,[[["self"]],[T]]],[11,R[61],E,E,7,[[["self"]],[T]]],[11,R[62],E,E,7,[[["self"]],[R[64]]]],[11,"from",E,E,8,[[[T]],[T]]],[11,R[65],E,E,8,[[],["i"]]],[11,"into",E,E,8,[[],[U]]],[11,R[59],E,E,8,[[[U]],[R[13]]]],[11,R[60],E,E,8,[[],[R[13]]]],[11,R[63],E,E,8,[[["self"]],[T]]],[11,R[61],E,E,8,[[["self"]],[T]]],[11,R[62],E,E,8,[[["self"]],[R[64]]]],[11,"from",E,E,9,[[[T]],[T]]],[11,"into",E,E,9,[[],[U]]],[11,R[59],E,E,9,[[[U]],[R[13]]]],[11,R[60],E,E,9,[[],[R[13]]]],[11,R[63],E,E,9,[[["self"]],[T]]],[11,R[61],E,E,9,[[["self"]],[T]]],[11,R[62],E,E,9,[[["self"]],[R[64]]]],[11,"from",E,E,10,[[[T]],[T]]],[11,"into",E,E,10,[[],[U]]],[11,R[59],E,E,10,[[[U]],[R[13]]]],[11,R[60],E,E,10,[[],[R[13]]]],[11,R[63],E,E,10,[[["self"]],[T]]],[11,R[61],E,E,10,[[["self"]],[T]]],[11,R[62],E,E,10,[[["self"]],[R[64]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,"into",E,E,0,[[],[U]]],[11,R[59],E,E,0,[[[U]],[R[13]]]],[11,R[60],E,E,0,[[],[R[13]]]],[11,R[63],E,E,0,[[["self"]],[T]]],[11,R[61],E,E,0,[[["self"]],[T]]],[11,R[62],E,E,0,[[["self"]],[R[64]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"into",E,E,1,[[],[U]]],[11,R[59],E,E,1,[[[U]],[R[13]]]],[11,R[60],E,E,1,[[],[R[13]]]],[11,R[63],E,E,1,[[["self"]],[T]]],[11,R[61],E,E,1,[[["self"]],[T]]],[11,R[62],E,E,1,[[["self"]],[R[64]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,"into",E,E,2,[[],[U]]],[11,R[59],E,E,2,[[[U]],[R[13]]]],[11,R[60],E,E,2,[[],[R[13]]]],[11,R[63],E,E,2,[[["self"]],[T]]],[11,R[61],E,E,2,[[["self"]],[T]]],[11,R[62],E,E,2,[[["self"]],[R[64]]]],[11,R[66],E,E,11,[[["self"]],[T]]],[11,R[67],E,E,11,[[[T],["self"]]]],[11,"from",E,E,11,[[[T]],[T]]],[11,"into",E,E,11,[[],[U]]],[11,R[59],E,E,11,[[[U]],[R[13]]]],[11,R[60],E,E,11,[[],[R[13]]]],[11,R[63],E,E,11,[[["self"]],[T]]],[11,R[61],E,E,11,[[["self"]],[T]]],[11,R[62],E,E,11,[[["self"]],[R[64]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,"into",E,E,3,[[],[U]]],[11,R[59],E,E,3,[[[U]],[R[13]]]],[11,R[60],E,E,3,[[],[R[13]]]],[11,R[63],E,E,3,[[["self"]],[T]]],[11,R[61],E,E,3,[[["self"]],[T]]],[11,R[62],E,E,3,[[["self"]],[R[64]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,"into",E,E,4,[[],[U]]],[11,R[59],E,E,4,[[[U]],[R[13]]]],[11,R[60],E,E,4,[[],[R[13]]]],[11,R[63],E,E,4,[[["self"]],[T]]],[11,R[61],E,E,4,[[["self"]],[T]]],[11,R[62],E,E,4,[[["self"]],[R[64]]]],[11,"from",E,E,12,[[[T]],[T]]],[11,"into",E,E,12,[[],[U]]],[11,R[59],E,E,12,[[[U]],[R[13]]]],[11,R[60],E,E,12,[[],[R[13]]]],[11,R[63],E,E,12,[[["self"]],[T]]],[11,R[61],E,E,12,[[["self"]],[T]]],[11,R[62],E,E,12,[[["self"]],[R[64]]]],[11,"from",E,E,13,[[[T]],[T]]],[11,R[65],E,E,13,[[],["i"]]],[11,"into",E,E,13,[[],[U]]],[11,R[59],E,E,13,[[[U]],[R[13]]]],[11,R[60],E,E,13,[[],[R[13]]]],[11,R[63],E,E,13,[[["self"]],[T]]],[11,R[61],E,E,13,[[["self"]],[T]]],[11,R[62],E,E,13,[[["self"]],[R[64]]]],[11,R[66],E,E,5,[[["self"]],[T]]],[11,R[67],E,E,5,[[[T],["self"]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,"into",E,E,5,[[],[U]]],[11,R[59],E,E,5,[[[U]],[R[13]]]],[11,R[60],E,E,5,[[],[R[13]]]],[11,R[63],E,E,5,[[["self"]],[T]]],[11,R[61],E,E,5,[[["self"]],[T]]],[11,R[62],E,E,5,[[["self"]],[R[64]]]],[11,R[66],E,E,6,[[["self"]],[T]]],[11,R[67],E,E,6,[[[T],["self"]]]],[11,"from",E,E,6,[[[T]],[T]]],[11,"into",E,E,6,[[],[U]]],[11,R[59],E,E,6,[[[U]],[R[13]]]],[11,R[60],E,E,6,[[],[R[13]]]],[11,R[63],E,E,6,[[["self"]],[T]]],[11,R[61],E,E,6,[[["self"]],[T]]],[11,R[62],E,E,6,[[["self"]],[R[64]]]],[11,"drop",E,E,9,[[["self"]]]],[11,"next",E,E,8,[[["self"]],[[R[13],["entry"]],[R[14],[R[13]]]]]],[11,"next",E,E,13,[[["self"]],[[R[14],[R[13]]],[R[13],["paxextension"]]]]],[11,"eq",E,E,5,[[["self"],[R[21]]],["bool"]]],[11,"ne",E,E,5,[[["self"],[R[21]]],["bool"]]],[11,"eq",E,E,6,[[["self"],[R[30]]],["bool"]]],[11,"default",E,E,0,[[],["self"]]],[11,"clone",E,E,5,[[["self"]],[R[21]]]],[11,"clone",E,E,6,[[["self"]],[R[30]]]],[11,"clone",E,E,11,[[["self"]],[R[24]]]],[11,"fmt",E,E,5,[[["self"],[R[68]]],[R[13]]]],[11,"fmt",E,E,6,[[["self"],[R[68]]],[R[13]]]],[11,"fmt",E,E,11,[[["self"],[R[68]]],[R[13]]]],[11,"fmt",E,E,3,[[["self"],[R[68]]],[R[13]]]],[11,"fmt",E,E,4,[[["self"],[R[68]]],[R[13]]]],[11,"fmt",E,E,1,[[["self"],[R[68]]],[R[13]]]],[11,"fmt",E,E,2,[[["self"],[R[68]]],[R[13]]]],[11,"read",E,E,10,[[["self"]],[["usize"],[R[13],["usize"]]]]]],"p":[[3,R[69]],[3,R[70]],[3,R[71]],[3,R[72]],[3,R[73]],[4,R[74]],[4,R[75]],[3,"Archive"],[3,"Entries"],[3,"Builder"],[3,"Entry"],[3,"Header"],[3,R[76]],[3,R[77]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);